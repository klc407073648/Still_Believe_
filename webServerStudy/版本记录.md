
# 项目学习过程
来源：https://github.com/linyacool/WebServer
从0.1最初形成到一点一点改进到0.6，到最终看了muduo，痛下决心重写，最终的版本完全从头再来了，但有了前面的经验，写起来顺畅了不少，但花了比之前所有加起来还要长的时间
## 0.1

第一版是看了很多Github上别人写的服务器，以及博客上的一些总结，结合自己的理解写出来的。模型结构如下：

* 使用了epoll边沿触发+EPOLLONESHOT+非阻塞IO
* 使用了一个固定线程数的线程池
* 实现了一个任务队列，由条件变量触发通知新任务的到来
* 实现了一个小根堆的定时器及时剔除超时请求，使用了STL的优先队列来管理定时器
* 解析了HTTP的get、post请求，支持长短连接
* mime设计为单例模式
* 线程的工作分配为：
    * 主线程负责等待epoll中的事件，并把到来的事件放进任务队列，在每次循环的结束剔除超时请求和被置为删除的时间结点
    * 工作线程阻塞在条件变量的等待中，新任务到来后，某一工作线程会被唤醒，执行具体的IO操作和计算任务，如果需要继续监听，会添加到epoll中  

* 锁的使用有两处：
    * 第一处是任务队列的添加和取操作，都需要加锁，并配合条件变量，跨越了多个线程。
    * 第二处是定时器结点的添加和删除，需要加锁，主线程和工作线程都要操作定时器队列。

第一版的服务器已经相对较完整了，该有的功能都已经具备了

## 0.2

在第一版的基础上，优化了代码结构，自己设计了RAII锁机制，使锁能够自动释放，并修复了一些小的bug

## 0.3

* 几乎全部的裸指针被智能指针替代
* 利用weak_ptr解决时间结点和HTTP类互指的问题
* 任务队列的任务结构从函数指针+参数指针转换为C++11的function  


## 0.4

* 为不提供拷贝构造和赋值运算符的类添加了noncopyable基类
* 重写了RAII机制的锁，学习muduo中的做法
* 重写了单例模式，将双重加锁改为更简单而安全的pthread_once()

## 0.5

* 修复了一些bug，稍微调整了类的结构
* 封装了条件变量

## 0.6

* 仿照muduo，写了4个缓冲区的异步Log日志，没有区分优先级，其它基本都具备了

